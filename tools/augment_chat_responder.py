#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Augment èŠå¤©å¯¹è¯æ¡†æ™ºèƒ½å›å¤å·¥å…·
ä¸“é—¨å¤„ç†VSCodeä¸­Augmentå¯¹è¯çš„"Would you like me to keep going?"æç¤º
ç¡®ä¿åœ¨æ­£ç¡®çš„å¯¹è¯æ¡†ä½ç½®è¾“å…¥"è¯·ç»§ç»­"
"""

import sys
import os
import time
import win32gui
import win32con
import win32api
from datetime import datetime
import win32clipboard

# æ·»åŠ å½“å‰ç›®å½•åˆ°è·¯å¾„
sys.path.append(os.path.dirname(__file__))

try:
    from uia_module import UIAModule
    from uictrl import UIController
except ImportError as e:
    print(f"âŒ å¯¼å…¥æ¨¡å—å¤±è´¥: {e}")
    sys.exit(1)

class AugmentChatResponder:
    """AugmentèŠå¤©å¯¹è¯æ¡†æ™ºèƒ½å›å¤å™¨"""
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.uia_module = UIAModule(verbose=verbose)
        self.ui_controller = UIController()
        
    def log(self, message: str, icon: str = "â„¹ï¸"):
        """æ—¥å¿—è¾“å‡º"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] {icon} {message}")
    
    def find_chat_input_box(self, root_element):
        """æŸ¥æ‰¾AugmentèŠå¤©è¾“å…¥æ¡†"""
        chat_input_candidates = []
        
        # æœç´¢ç­–ç•¥1: æŸ¥æ‰¾åŒ…å«"Ask or instruct"çš„å…ƒç´ é™„è¿‘çš„è¾“å…¥æ¡†
        try:
            results = self.uia_module.search_text_in_tree(
                root_element, 
                ["Ask or instruct", "instruct", "Ask"], 
                max_depth=15
            )
            
            for result in results:
                if self.verbose:
                    self.log(f"æ‰¾åˆ°æŒ‡å¯¼æ–‡æœ¬: '{result.get('text_content', '')[:50]}...'")
                
                # è·å–è¿™ä¸ªå…ƒç´ çš„çˆ¶å…ƒç´ ï¼Œç„¶åæŸ¥æ‰¾é™„è¿‘çš„ç¼–è¾‘æ¡†
                element = result.get('uia_element')
                if element:
                    # å°è¯•åœ¨åŒä¸€çˆ¶å…ƒç´ ä¸‹æŸ¥æ‰¾ç¼–è¾‘æ¡†
                    try:
                        parent = element.GetCurrentParent()
                        children = parent.FindAll(
                            self.uia_module.ui_automation.CreateTreeScope_Children(),
                            self.uia_module.ui_automation.CreateTrueCondition()
                        )
                        
                        for i in range(children.Length):
                            child = children.GetElement(i)
                            control_type = child.GetCurrentControlType()
                            
                            # æŸ¥æ‰¾ç¼–è¾‘æ¡†ç±»å‹çš„æ§ä»¶
                            if control_type in [50004, 50030]:  # Edit, Document
                                rect = child.GetCurrentBoundingRectangle()
                                if rect.width > 200 and rect.height > 30:  # åˆç†çš„è¾“å…¥æ¡†å¤§å°
                                    chat_input_candidates.append({
                                        'element': child,
                                        'rect': {
                                            'left': rect.left,
                                            'top': rect.top,
                                            'width': rect.width,
                                            'height': rect.height
                                        },
                                        'source': 'near_instruction'
                                    })
                                    if self.verbose:
                                        self.log(f"æ‰¾åˆ°å€™é€‰è¾“å…¥æ¡†: {rect.width}x{rect.height} at ({rect.left}, {rect.top})")
                    except:
                        pass
        except Exception as e:
            if self.verbose:
                self.log(f"æœç´¢æŒ‡å¯¼æ–‡æœ¬æ—¶å‡ºé”™: {e}")
        
        # æœç´¢ç­–ç•¥2: æŸ¥æ‰¾åº•éƒ¨çš„ç¼–è¾‘æ¡†ï¼ˆé€šå¸¸èŠå¤©è¾“å…¥æ¡†åœ¨åº•éƒ¨ï¼‰
        try:
            all_elements = self.uia_module.search_text_in_tree(
                root_element, 
                [""],  # ç©ºå­—ç¬¦ä¸²ä¼šåŒ¹é…æ‰€æœ‰æ–‡æœ¬å…ƒç´ 
                max_depth=15
            )
            
            edit_boxes = []
            for result in all_elements:
                control_type = result.get('control_type', '')
                if control_type in ['Edit', 'Document']:
                    rect = result.get('bounding_rect')
                    if rect and rect['width'] > 200 and rect['height'] > 20:
                        edit_boxes.append(result)
            
            # æŒ‰Yåæ ‡æ’åºï¼Œæ‰¾åˆ°æœ€åº•éƒ¨çš„ç¼–è¾‘æ¡†
            edit_boxes.sort(key=lambda x: x.get('bounding_rect', {}).get('top', 0), reverse=True)
            
            for edit_box in edit_boxes[:3]:  # åªæ£€æŸ¥æœ€åº•éƒ¨çš„3ä¸ª
                rect = edit_box.get('bounding_rect')
                chat_input_candidates.append({
                    'element': edit_box.get('uia_element'),
                    'rect': rect,
                    'source': 'bottom_edit_box'
                })
                if self.verbose:
                    self.log(f"æ‰¾åˆ°åº•éƒ¨ç¼–è¾‘æ¡†: {rect['width']}x{rect['height']} at ({rect['left']}, {rect['top']})")
                    
        except Exception as e:
            if self.verbose:
                self.log(f"æœç´¢åº•éƒ¨ç¼–è¾‘æ¡†æ—¶å‡ºé”™: {e}")
        
        return chat_input_candidates
    
    def click_and_focus_input(self, hwnd, rect):
        """ç‚¹å‡»å¹¶èšç„¦åˆ°è¾“å…¥æ¡†"""
        try:
            # æ¿€æ´»çª—å£
            win32gui.SetForegroundWindow(hwnd)
            time.sleep(0.2)
            
            # è®¡ç®—ç‚¹å‡»ä½ç½®ï¼ˆè¾“å…¥æ¡†çš„ä¸­å¿ƒï¼‰
            click_x = rect['left'] + rect['width'] // 2
            click_y = rect['top'] + rect['height'] // 2
            
            if self.verbose:
                self.log(f"åœ¨ä½ç½® ({click_x}, {click_y}) ç‚¹å‡»è¾“å…¥æ¡†")
            
            # ç§»åŠ¨é¼ æ ‡å¹¶ç‚¹å‡»
            win32api.SetCursorPos((click_x, click_y))
            time.sleep(0.1)
            
            # æ‰§è¡Œç‚¹å‡»
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
            time.sleep(0.3)
            
            return True
            
        except Exception as e:
            if self.verbose:
                self.log(f"ç‚¹å‡»è¾“å…¥æ¡†å¤±è´¥: {e}")
            return False
    
    def clear_and_type_response(self, hwnd):
        """æ¸…é™¤è¾“å…¥æ¡†å¹¶è¾“å…¥å›å¤"""
        try:
            # å…¨é€‰ç°æœ‰å†…å®¹
            win32api.keybd_event(win32con.VK_CONTROL, 0, 0, 0)
            win32api.keybd_event(ord('A'), 0, 0, 0)
            win32api.keybd_event(ord('A'), 0, win32con.KEYEVENTF_KEYUP, 0)
            win32api.keybd_event(win32con.VK_CONTROL, 0, win32con.KEYEVENTF_KEYUP, 0)
            time.sleep(0.1)
            
            # åˆ é™¤ç°æœ‰å†…å®¹
            win32api.keybd_event(win32con.VK_DELETE, 0, 0, 0)
            win32api.keybd_event(win32con.VK_DELETE, 0, win32con.KEYEVENTF_KEYUP, 0)
            time.sleep(0.1)
            
            # ä½¿ç”¨å‰ªè´´æ¿è¾“å…¥ä¸­æ–‡
            win32clipboard.OpenClipboard()
            win32clipboard.EmptyClipboard()
            win32clipboard.SetClipboardText("è¯·ç»§ç»­")
            win32clipboard.CloseClipboard()
            
            # Ctrl+V ç²˜è´´
            win32api.keybd_event(win32con.VK_CONTROL, 0, 0, 0)
            win32api.keybd_event(ord('V'), 0, 0, 0)
            win32api.keybd_event(ord('V'), 0, win32con.KEYEVENTF_KEYUP, 0)
            win32api.keybd_event(win32con.VK_CONTROL, 0, win32con.KEYEVENTF_KEYUP, 0)
            
            time.sleep(0.3)
            
            # å‘é€å›è½¦é”®
            self.log("å‘é€å›è½¦é”®...")
            win32api.keybd_event(win32con.VK_RETURN, 0, 0, 0)
            win32api.keybd_event(win32con.VK_RETURN, 0, win32con.KEYEVENTF_KEYUP, 0)
            
            return True
            
        except Exception as e:
            self.log(f"è¾“å…¥å›å¤å¤±è´¥: {e}", "âŒ")
            return False
    
    def respond_to_keep_going_prompt(self):
        """æ£€æµ‹å¹¶å“åº”'keep going'æç¤º"""
        try:
            # æŸ¥æ‰¾VSCodeçª—å£
            vscode_window = self.uia_module.find_vscode_window()
            if not vscode_window:
                self.log("æœªæ‰¾åˆ°VSCodeçª—å£", "âŒ")
                return False
            
            hwnd = int(vscode_window['id'])
            root_element = self.uia_module.get_element_from_hwnd(hwnd)
            if not root_element:
                self.log("æ— æ³•è·å–UIæ ¹å…ƒç´ ", "âŒ")
                return False
            
            # 1. é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰"keep going"æç¤º
            self.log("æ£€æŸ¥æ˜¯å¦å­˜åœ¨'keep going'æç¤º...")
            found_prompt = False
            prompt_text = ""
            
            for keyword in ["going", "keep", "would"]:
                try:
                    results = self.uia_module.search_text_in_tree(
                        root_element,
                        [keyword],
                        max_depth=12,
                        case_sensitive=False
                    )
                    
                    for result in results:
                        text_content = result.get('text_content', '').lower()
                        if 'would' in text_content and 'keep' in text_content and 'going' in text_content:
                            found_prompt = True
                            prompt_text = result.get('text_content', '')
                            self.log(f"æ£€æµ‹åˆ°æç¤º: '{prompt_text[:60]}...'", "ğŸ¯")
                            break
                    
                    if found_prompt:
                        break
                        
                except Exception:
                    pass
            
            if not found_prompt:
                self.log("æœªæ£€æµ‹åˆ°'keep going'æç¤º")
                return False
            
            # 2. æŸ¥æ‰¾èŠå¤©è¾“å…¥æ¡†
            self.log("æŸ¥æ‰¾AugmentèŠå¤©è¾“å…¥æ¡†...")
            input_candidates = self.find_chat_input_box(root_element)
            
            if not input_candidates:
                self.log("æœªæ‰¾åˆ°èŠå¤©è¾“å…¥æ¡†ï¼Œä½¿ç”¨é€šç”¨æ–¹æ³•", "âš ï¸")
                # å¤‡ç”¨æ–¹æ³•ï¼šæ¿€æ´»çª—å£åç›´æ¥è¾“å…¥
                win32gui.SetForegroundWindow(hwnd)
                time.sleep(0.5)
                return self.clear_and_type_response(hwnd)
            
            # 3. å°è¯•ä½¿ç”¨æ‰¾åˆ°çš„è¾“å…¥æ¡†
            for i, candidate in enumerate(input_candidates):
                self.log(f"å°è¯•è¾“å…¥æ¡† {i+1}/{len(input_candidates)} (æ¥æº: {candidate['source']})")
                
                # ç‚¹å‡»å¹¶èšç„¦åˆ°è¾“å…¥æ¡†
                if self.click_and_focus_input(hwnd, candidate['rect']):
                    # è¾“å…¥å›å¤
                    if self.clear_and_type_response(hwnd):
                        self.log("æˆåŠŸå‘é€å›å¤!", "âœ…")
                        return True
                    else:
                        self.log(f"è¾“å…¥æ¡† {i+1} è¾“å…¥å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª...")
                        continue
                else:
                    self.log(f"è¾“å…¥æ¡† {i+1} ç‚¹å‡»å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª...")
                    continue
            
            self.log("æ‰€æœ‰è¾“å…¥æ¡†å°è¯•å¤±è´¥", "âŒ")
            return False
            
        except Exception as e:
            self.log(f"å¤„ç†è¿‡ç¨‹å‡ºé”™: {e}", "âŒ")
            return False

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='AugmentèŠå¤©å¯¹è¯æ¡†æ™ºèƒ½å›å¤å·¥å…·')
    parser.add_argument('--verbose', '-v', action='store_true', help='è¯¦ç»†è¾“å‡º')
    parser.add_argument('--monitor', action='store_true', help='æŒç»­ç›‘æ§æ¨¡å¼')
    parser.add_argument('--interval', type=int, default=5, help='ç›‘æ§é—´éš”(ç§’)')
    parser.add_argument('--max-checks', type=int, default=10, help='æœ€å¤§æ£€æŸ¥æ¬¡æ•°')
    
    args = parser.parse_args()
    
    responder = AugmentChatResponder(verbose=args.verbose)
    
    if args.monitor:
        # ç›‘æ§æ¨¡å¼
        print(f"ğŸ”„ å¼€å§‹ç›‘æ§æ¨¡å¼ (é—´éš”: {args.interval}ç§’, æœ€å¤§æ£€æŸ¥: {args.max_checks}æ¬¡)")
        
        for i in range(args.max_checks):
            print(f"\n=== æ£€æŸ¥ {i+1}/{args.max_checks} ===")
            
            success = responder.respond_to_keep_going_prompt()
            if success:
                print("âœ… æ£€æµ‹åˆ°æç¤ºå¹¶æˆåŠŸå¤„ç†!")
                break
            else:
                print("â„¹ï¸ æœªæ£€æµ‹åˆ°éœ€è¦å¤„ç†çš„æç¤º")
            
            if i < args.max_checks - 1:  # ä¸æ˜¯æœ€åä¸€æ¬¡æ£€æŸ¥
                print(f"â³ ç­‰å¾… {args.interval} ç§’åç»§ç»­...")
                time.sleep(args.interval)
        
        print(f"\nğŸ ç›‘æ§ç»“æŸ")
    else:
        # å•æ¬¡æ£€æŸ¥
        print("ğŸ” æ£€æŸ¥'keep going'æç¤ºå¹¶è‡ªåŠ¨å“åº”...")
        success = responder.respond_to_keep_going_prompt()
        if success:
            print("âœ… æˆåŠŸæ£€æµ‹å¹¶å¤„ç†æç¤º!")
        else:
            print("â„¹ï¸ å½“å‰æœªæ£€æµ‹åˆ°éœ€è¦å¤„ç†çš„æç¤º")

if __name__ == "__main__":
    main() 