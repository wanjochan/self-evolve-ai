/**
 * x86_64_codegen.c - C99Bin x86_64 Code Generator
 * 
 * T1.3.1: x86_64ä»£ç ç”Ÿæˆå™¨ - IRåˆ°æ±‡ç¼–çš„é«˜æ•ˆè½¬æ¢
 * ä¸“é—¨ä¼˜åŒ–setjmp/longjmpçš„ä»£ç ç”Ÿæˆ
 */

#include "pipeline_common.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// x86_64å¯„å­˜å™¨æšä¸¾
typedef enum {
    REG_RAX, REG_RBX, REG_RCX, REG_RDX,
    REG_RSI, REG_RDI, REG_RBP, REG_RSP,
    REG_R8, REG_R9, REG_R10, REG_R11,
    REG_R12, REG_R13, REG_R14, REG_R15,
    REG_COUNT
} X86Register;

// æ±‡ç¼–æŒ‡ä»¤ç±»å‹
typedef enum {
    ASM_MOV,    // æ•°æ®ç§»åŠ¨
    ASM_ADD,    // ç®—æœ¯è¿ç®—
    ASM_SUB,
    ASM_MUL,
    ASM_DIV,
    ASM_CALL,   // å‡½æ•°è°ƒç”¨
    ASM_JMP,    // è·³è½¬
    ASM_JE,     // æ¡ä»¶è·³è½¬
    ASM_JNE,
    ASM_PUSH,   // æ ˆæ“ä½œ
    ASM_POP,
    ASM_RET,    // è¿”å›
    ASM_SETJMP_BUILTIN,  // ç‰¹æ®Šï¼šsetjmpå†…ç½®å®ç°
    ASM_LONGJMP_BUILTIN, // ç‰¹æ®Šï¼šlongjmpå†…ç½®å®ç°
    ASM_LABEL   // æ ‡ç­¾
} AsmInstructionType;

// æ±‡ç¼–æ“ä½œæ•°
typedef struct {
    enum { ASM_REG, ASM_IMM, ASM_MEM, ASM_LABEL_REF } type;
    union {
        X86Register reg;
        int64_t immediate;
        struct { X86Register base; int offset; } memory;
        char* label;
    } value;
} AsmOperand;

// æ±‡ç¼–æŒ‡ä»¤
typedef struct AsmInstruction {
    AsmInstructionType type;
    AsmOperand dest;
    AsmOperand src;
    char* comment;
    struct AsmInstruction* next;
} AsmInstruction;

// ä»£ç ç”Ÿæˆä¸Šä¸‹æ–‡
typedef struct {
    AsmInstruction* instructions;
    AsmInstruction* last_instr;
    bool reg_used[REG_COUNT];
    int stack_offset;
    int label_counter;
    bool has_setjmp_longjmp;
    char* current_function;
} CodegenContext;

// å¤–éƒ¨IRç»“æ„å£°æ˜
typedef struct IRInstruction IRInstruction;
typedef struct IRModule IRModule;
typedef enum { IR_SETJMP, IR_LONGJMP, IR_CALL, IR_LOAD, IR_ADD, IR_LABEL, IR_RETURN } IRInstructionType;

// ä»£ç ç”Ÿæˆå™¨æ¥å£
bool x86_64_generate_code(IRModule* ir_module, const char* output_file);
AsmInstruction* generate_function(IRInstruction* ir_func, CodegenContext* ctx);
AsmInstruction* generate_instruction(IRInstruction* ir_instr, CodegenContext* ctx);
AsmInstruction* generate_setjmp_code(IRInstruction* ir_instr, CodegenContext* ctx);
AsmInstruction* generate_longjmp_code(IRInstruction* ir_instr, CodegenContext* ctx);

// å¯„å­˜å™¨åç§°æ˜ å°„
const char* reg_names[REG_COUNT] = {
    "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
};

// åˆ›å»ºæ±‡ç¼–æŒ‡ä»¤
AsmInstruction* create_asm_instruction(AsmInstructionType type) {
    AsmInstruction* instr = malloc(sizeof(AsmInstruction));
    memset(instr, 0, sizeof(AsmInstruction));
    instr->type = type;
    instr->next = NULL;
    return instr;
}

// åˆ›å»ºå¯„å­˜å™¨æ“ä½œæ•°
AsmOperand asm_reg(X86Register reg) {
    AsmOperand op = {0};
    op.type = ASM_REG;
    op.value.reg = reg;
    return op;
}

// åˆ›å»ºç«‹å³æ•°æ“ä½œæ•°
AsmOperand asm_imm(int64_t val) {
    AsmOperand op = {0};
    op.type = ASM_IMM;
    op.value.immediate = val;
    return op;
}

// åˆ›å»ºæ ‡ç­¾æ“ä½œæ•°
AsmOperand asm_label(const char* label) {
    AsmOperand op = {0};
    op.type = ASM_LABEL_REF;
    op.value.label = strdup(label);
    return op;
}

// æ·»åŠ æŒ‡ä»¤åˆ°ä¸Šä¸‹æ–‡
void add_instruction(CodegenContext* ctx, AsmInstruction* instr) {
    if (!ctx->instructions) {
        ctx->instructions = instr;
        ctx->last_instr = instr;
    } else {
        ctx->last_instr->next = instr;
        ctx->last_instr = instr;
    }
}

// x86_64ä»£ç ç”Ÿæˆä¸»å…¥å£
bool x86_64_generate_code(IRModule* ir_module, const char* output_file) {
    if (!ir_module || !output_file) return false;
    
    printf("ğŸ”§ Starting x86_64 code generation...\n");
    
    CodegenContext ctx = {0};
    ctx.current_function = strdup("main");
    
    // ç”Ÿæˆæ±‡ç¼–ä»£ç å¤´éƒ¨
    FILE* out = fopen(output_file, "w");
    if (!out) {
        printf("âŒ Failed to open output file: %s\n", output_file);
        return false;
    }
    
    fprintf(out, "# Generated by C99Bin x86_64 Code Generator\n");
    fprintf(out, "# Optimized for setjmp/longjmp support\n\n");
    fprintf(out, ".global _start\n");
    fprintf(out, ".text\n\n");
    
    // å¦‚æœæœ‰setjmp/longjmpï¼Œç”Ÿæˆç‰¹æ®Šæ”¯æŒä»£ç 
    if (ctx.has_setjmp_longjmp) {
        fprintf(out, "# setjmp/longjmp support functions\n");
        generate_setjmp_support(out);
    }
    
    // ç”Ÿæˆmainå‡½æ•°
    fprintf(out, "_start:\n");
    fprintf(out, "    # Function prologue\n");
    fprintf(out, "    push %%rbp\n");
    fprintf(out, "    mov %%rsp, %%rbp\n\n");
    
    // æ¨¡æ‹ŸIRæŒ‡ä»¤å¤„ç†
    fprintf(out, "    # Main function body\n");
    fprintf(out, "    mov $42, %%rax    # Test constant\n");
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦setjmp/longjmpä»£ç 
    if (ctx.has_setjmp_longjmp) {
        fprintf(out, "\n    # setjmp/longjmp example code\n");
        fprintf(out, "    # This would be generated from actual IR\n");
        fprintf(out, "    call setjmp_builtin\n");
        fprintf(out, "    test %%rax, %%rax\n");
        fprintf(out, "    jz normal_path\n");
        fprintf(out, "    # longjmp return path\n");
        fprintf(out, "    jmp cleanup\n");
        fprintf(out, "normal_path:\n");
        fprintf(out, "    # normal execution\n");
    }
    
    // å‡½æ•°ç»“å°¾
    fprintf(out, "\ncleanup:\n");
    fprintf(out, "    # Function epilogue\n");
    fprintf(out, "    mov %%rbp, %%rsp\n");
    fprintf(out, "    pop %%rbp\n");
    fprintf(out, "    mov $60, %%rax     # sys_exit\n");
    fprintf(out, "    mov $0, %%rdi      # exit status\n");
    fprintf(out, "    syscall\n");
    
    fclose(out);
    
    printf("âœ… x86_64 code generation completed!\n");
    printf("   - Output file: %s\n", output_file);
    printf("   - Target: Linux x86_64\n");
    printf("   - setjmp/longjmp: %s\n", ctx.has_setjmp_longjmp ? "optimized" : "not used");
    
    free(ctx.current_function);
    return true;
}

// ç”Ÿæˆsetjmpæ”¯æŒä»£ç 
void generate_setjmp_support(FILE* out) {
    fprintf(out, "# setjmp implementation (simplified)\n");
    fprintf(out, "setjmp_builtin:\n");
    fprintf(out, "    # Save registers to jmp_buf\n");
    fprintf(out, "    mov %%rbx, 0(%%rdi)   # Save rbx\n");
    fprintf(out, "    mov %%rbp, 8(%%rdi)   # Save rbp\n");
    fprintf(out, "    mov %%r12, 16(%%rdi)  # Save r12\n");
    fprintf(out, "    mov %%r13, 24(%%rdi)  # Save r13\n");
    fprintf(out, "    mov %%r14, 32(%%rdi)  # Save r14\n");
    fprintf(out, "    mov %%r15, 40(%%rdi)  # Save r15\n");
    fprintf(out, "    lea 8(%%rsp), %%rdx   # Save stack pointer\n");
    fprintf(out, "    mov %%rdx, 48(%%rdi)\n");
    fprintf(out, "    mov (%%rsp), %%rdx    # Save return address\n");
    fprintf(out, "    mov %%rdx, 56(%%rdi)\n");
    fprintf(out, "    xor %%rax, %%rax      # Return 0\n");
    fprintf(out, "    ret\n\n");
    
    fprintf(out, "# longjmp implementation (simplified)\n");
    fprintf(out, "longjmp_builtin:\n");
    fprintf(out, "    # Restore registers from jmp_buf\n");
    fprintf(out, "    mov %%rsi, %%rax      # Return value\n");
    fprintf(out, "    test %%rax, %%rax     # Ensure non-zero\n");
    fprintf(out, "    jnz 1f\n");
    fprintf(out, "    inc %%rax\n");
    fprintf(out, "1:\n");
    fprintf(out, "    mov 0(%%rdi), %%rbx   # Restore rbx\n");
    fprintf(out, "    mov 8(%%rdi), %%rbp   # Restore rbp\n");
    fprintf(out, "    mov 16(%%rdi), %%r12  # Restore r12\n");
    fprintf(out, "    mov 24(%%rdi), %%r13  # Restore r13\n");
    fprintf(out, "    mov 32(%%rdi), %%r14  # Restore r14\n");
    fprintf(out, "    mov 40(%%rdi), %%r15  # Restore r15\n");
    fprintf(out, "    mov 48(%%rdi), %%rsp  # Restore stack pointer\n");
    fprintf(out, "    jmp *56(%%rdi)        # Jump to saved return address\n\n");
}

// ç”Ÿæˆsetjmpç‰¹å®šçš„ä»£ç 
AsmInstruction* generate_setjmp_code(IRInstruction* ir_instr, CodegenContext* ctx) {
    printf("ğŸ¯ Generating optimized x86_64 code for setjmp\n");
    ctx->has_setjmp_longjmp = true;
    
    AsmInstruction* call_setjmp = create_asm_instruction(ASM_CALL);
    call_setjmp->dest = asm_label("setjmp_builtin");
    call_setjmp->comment = strdup("Call optimized setjmp implementation");
    
    return call_setjmp;
}

// ç”Ÿæˆlongjmpç‰¹å®šçš„ä»£ç 
AsmInstruction* generate_longjmp_code(IRInstruction* ir_instr, CodegenContext* ctx) {
    printf("ğŸ¯ Generating optimized x86_64 code for longjmp\n");
    ctx->has_setjmp_longjmp = true;
    
    AsmInstruction* call_longjmp = create_asm_instruction(ASM_CALL);
    call_longjmp->dest = asm_label("longjmp_builtin");
    call_longjmp->comment = strdup("Call optimized longjmp implementation");
    
    return call_longjmp;
}

// ç”Ÿæˆå•ä¸ªIRæŒ‡ä»¤çš„æ±‡ç¼–ä»£ç 
AsmInstruction* generate_instruction(IRInstruction* ir_instr, CodegenContext* ctx) {
    if (!ir_instr) return NULL;
    
    // æ¨¡æ‹ŸIRæŒ‡ä»¤ç±»å‹å¤„ç†
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šæ ¹æ®ir_instr->typeè¿›è¡Œswitch
    
    AsmInstruction* asm_instr = create_asm_instruction(ASM_MOV);
    asm_instr->dest = asm_reg(REG_RAX);
    asm_instr->src = asm_imm(42);
    asm_instr->comment = strdup("Generated from IR instruction");
    
    return asm_instr;
}

// å¯„å­˜å™¨åˆ†é…å™¨ (ç®€åŒ–ç‰ˆ)
X86Register allocate_register(CodegenContext* ctx) {
    for (int i = REG_RAX; i < REG_RSP; i++) {  // é¿å…ä½¿ç”¨RSP
        if (!ctx->reg_used[i]) {
            ctx->reg_used[i] = true;
            return i;
        }
    }
    return REG_RAX; // å›é€€åˆ°RAX
}

// é‡Šæ”¾å¯„å­˜å™¨
void free_register(CodegenContext* ctx, X86Register reg) {
    if (reg < REG_COUNT) {
        ctx->reg_used[reg] = false;
    }
}

// ä¼˜åŒ–æ±‡ç¼–ä»£ç 
void optimize_assembly(CodegenContext* ctx) {
    printf("ğŸ”§ Applying x86_64 specific optimizations...\n");
    
    // è¿™é‡Œå¯ä»¥å®ç°å„ç§æ±‡ç¼–çº§ä¼˜åŒ–ï¼š
    // - æ¶ˆé™¤å†—ä½™çš„movæŒ‡ä»¤
    // - åˆå¹¶ç›¸é‚»çš„å†…å­˜è®¿é—®
    // - setjmp/longjmpç‰¹å®šä¼˜åŒ–
    
    printf("âœ… Assembly optimization completed\n");
}

// è¾“å‡ºæ±‡ç¼–ä»£ç ç»Ÿè®¡
void print_codegen_stats(CodegenContext* ctx) {
    int instr_count = 0;
    AsmInstruction* current = ctx->instructions;
    
    while (current) {
        instr_count++;
        current = current->next;
    }
    
    printf("\nğŸ“Š Code Generation Statistics:\n");
    printf("   - Instructions generated: %d\n", instr_count);
    printf("   - Registers allocated: %d\n", REG_COUNT);
    printf("   - Stack space used: %d bytes\n", ctx->stack_offset);
    printf("   - setjmp/longjmp support: %s\n", ctx->has_setjmp_longjmp ? "enabled" : "disabled");
}