; TIR (Tiny IR) 生成器
; 实现从中间表示到目标代码的转换

%include "opcodes.inc"

section .data
    ; TIR 操作码到目标指令的映射
    tir_opcodes:
        dd 0  ; 未使用
        dd OP_ADD  ; TIR_ADD = 1
        dd OP_SUB  ; TIR_SUB
        dd OP_MUL  ; TIR_MUL
        dd OP_DIV  ; TIR_DIV
        dd OP_MOD  ; TIR_MOD
        dd OP_AND  ; TIR_AND
        dd OP_OR   ; TIR_OR
        dd OP_XOR  ; TIR_XOR
        dd OP_SHL  ; TIR_SHL
        dd OP_SHR  ; TIR_SHR
        dd OP_JMP  ; TIR_JMP
        dd OP_JE   ; TIR_JE
        dd OP_JNE  ; TIR_JNE
        dd OP_JG   ; TIR_JG
        dd OP_JL   ; TIR_JL
        dd OP_JGE  ; TIR_JGE
        dd OP_JLE  ; TIR_JLE
        dd OP_CALL ; TIR_CALL
        dd OP_RET  ; TIR_RET
        dd OP_MOV  ; TIR_MOV
        dd OP_LOAD ; TIR_LOAD
        dd OP_STORE ; TIR_STORE
        dd OP_HLT  ; TIR_HLT

section .text

; 生成目标代码
; 输入: esi = TIR 代码, edi = 输出缓冲区
generate_code:
    pusha
    
    mov ebp, esp
    sub esp, 8  ; 局部变量: [ebp-4] = 指令数, [ebp-8] = 当前指令地址
    
    ; 初始化
    mov dword [ebp-4], 0
    mov dword [ebp-8], 0
    
    ; 第一遍: 收集标签和计算地址
    mov esi, [ebp+8]  ; 获取 TIR 代码地址
    
first_pass:
    mov al, [esi]
    cmp al, 0xFF  ; 结束标记
    je second_pass
    
    ; 处理指令
    inc dword [ebp-4]  ; 指令计数加1
    
    ; 更新标签表
    call update_label_table
    
    ; 计算下一条指令地址
    call get_instruction_size
    add [ebp-8], eax
    
    ; 移动到下一条指令
    add esi, eax
    jmp first_pass

second_pass:
    ; 第二遍: 生成目标代码
    mov esi, [ebp+8]  ; 重置 TIR 代码指针
    
    ; 生成代码...
    
    popa
    ret

; 更新标签表
update_label_table:
    ; 实现标签解析和地址计算
    ret

; 获取指令大小
; 输入: esi = 指令地址
; 输出: eax = 指令大小
get_instruction_size:
    mov al, [esi]
    cmp al, 0x10  ; 跳转指令
    jb .arithmetic
    
    ; 处理跳转指令
    mov eax, 5  ; 跳转指令固定5字节
    ret
    
.arithmetic:
    ; 算术/逻辑指令
    mov eax, 4  ; 默认4字节
    ret
