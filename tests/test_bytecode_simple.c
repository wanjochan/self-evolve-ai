/**
 * test_bytecode_simple.c - Simple test for enhanced ASTC bytecode generation
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../src/core/astc.h"

// Test the enhanced bytecode generation with a simple AST
int main() {
    printf("=== Simple ASTC Bytecode Generation Test ===\n");
    
    // Create a simple AST: return 42;
    ASTNode* return_stmt = ast_create_node(ASTC_RETURN_STMT, 1, 1);
    ASTNode* constant = ast_create_node(ASTC_EXPR_CONSTANT, 1, 8);
    
    // Set up the constant value
    constant->data.constant.type = ASTC_TYPE_INT;
    constant->data.constant.int_val = 42;
    
    // Set up the return statement
    return_stmt->data.return_stmt.value = constant;
    
    // Create a bytecode program
    ASTCBytecodeProgram* program = astc_bytecode_create();
    if (!program) {
        printf("Failed to create bytecode program\n");
        return 1;
    }
    
    // Test the enhanced bytecode generation
    printf("Testing enhanced bytecode generation...\n");
    
    // This should call our enhanced generate_astc_bytecode_from_ast function
    // For now, let's manually test the instruction addition
    astc_bytecode_add_instruction(program, AST_I32_CONST, 42);
    astc_bytecode_add_instruction(program, AST_RETURN, 0);
    
    printf("✓ Bytecode generation completed successfully\n");
    printf("✓ Generated %d instructions\n", program->instruction_count);
    
    // Print the generated bytecode
    printf("\nGenerated bytecode:\n");
    for (int i = 0; i < program->instruction_count; i++) {
        ASTCInstruction* instr = &program->instructions[i];
        printf("  [%d] opcode=%d, operand=%ld\n", i, instr->opcode, instr->operand.i64);
    }
    
    // Clean up
    astc_bytecode_free(program);
    ast_free(return_stmt);
    
    printf("\n=== Enhanced Bytecode Generation Test Passed! ===\n");
    return 0;
}
