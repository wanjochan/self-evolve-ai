#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include "../src/core/module.h"

// 外部声明pipeline模块
extern Module module_pipeline;

int main() {
    printf("=== Real Compilation Pipeline Test ===\n");
    
    // 1. 初始化pipeline模块
    printf("1. Initializing pipeline module...\n");
    if (module_pipeline.init() != 0) {
        printf("ERROR: Failed to initialize pipeline module\n");
        return 1;
    }
    printf("   ✓ Pipeline module initialized\n");
    
    // 2. 测试真实的C代码编译
    printf("\n2. Testing real C code compilation...\n");
    const char* real_c_code = 
        "#include <stdio.h>\n"
        "int add(int a, int b) {\n"
        "    return a + b;\n"
        "}\n"
        "int main() {\n"
        "    int x = 10;\n"
        "    int y = 20;\n"
        "    int result = add(x, y);\n"
        "    printf(\"Result: %d\\n\", result);\n"
        "    return 0;\n"
        "}\n";
    
    printf("   Testing C code:\n%s\n", real_c_code);
    
    // 获取编译函数
    void* compile_func = module_pipeline.resolve("pipeline_compile");
    bool (*pipeline_compile)(const char*, void*) = (bool (*)(const char*, void*))compile_func;
    
    if (!pipeline_compile) {
        printf("ERROR: Could not resolve pipeline_compile function\n");
        return 1;
    }
    
    // 尝试编译
    printf("   Attempting compilation...\n");
    if (!pipeline_compile(real_c_code, NULL)) {
        void* get_error_func = module_pipeline.resolve("pipeline_get_error");
        const char* (*get_error)(void) = (const char* (*)(void))get_error_func;
        if (get_error) {
            printf("   ERROR: Compilation failed: %s\n", get_error());
        } else {
            printf("   ERROR: Compilation failed (no error details)\n");
        }
        printf("   This is expected - the implementation is simplified\n");
    } else {
        printf("   ✓ Compilation succeeded\n");
    }
    
    // 3. 检查生成的汇编代码
    printf("\n3. Checking generated assembly...\n");
    void* get_assembly_func = module_pipeline.resolve("pipeline_get_assembly");
    const char* (*get_assembly)(void) = (const char* (*)(void))get_assembly_func;
    
    if (get_assembly) {
        const char* assembly = get_assembly();
        if (assembly && strlen(assembly) > 0) {
            printf("   Generated assembly (%zu bytes):\n", strlen(assembly));
            // 只显示前几行
            char* line = strtok(strdup(assembly), "\n");
            int line_count = 0;
            while (line && line_count < 5) {
                printf("     %s\n", line);
                line = strtok(NULL, "\n");
                line_count++;
            }
            if (line) printf("     ... (truncated)\n");
        } else {
            printf("   No assembly code generated\n");
        }
    }
    
    // 4. 检查生成的字节码
    printf("\n4. Checking generated bytecode...\n");
    void* get_bytecode_func = module_pipeline.resolve("pipeline_get_bytecode");
    const uint8_t* (*get_bytecode)(size_t*) = (const uint8_t* (*)(size_t*))get_bytecode_func;
    
    if (get_bytecode) {
        size_t bytecode_size;
        const uint8_t* bytecode = get_bytecode(&bytecode_size);
        if (bytecode && bytecode_size > 0) {
            printf("   Generated bytecode (%zu bytes):\n", bytecode_size);
            printf("   Hex dump: ");
            for (size_t i = 0; i < (bytecode_size < 16 ? bytecode_size : 16); i++) {
                printf("%02x ", bytecode[i]);
            }
            if (bytecode_size > 16) printf("...");
            printf("\n");
        } else {
            printf("   No bytecode generated\n");
        }
    }
    
    // 5. 测试简单的C代码
    printf("\n5. Testing simple C code...\n");
    const char* simple_code = 
        "int main() {\n"
        "    return 42;\n"
        "}\n";
    
    printf("   Simple code: %s", simple_code);
    
    if (pipeline_compile(simple_code, NULL)) {
        printf("   ✓ Simple code compiled successfully\n");
        
        // 尝试执行
        void* execute_func = module_pipeline.resolve("pipeline_execute");
        bool (*pipeline_execute)(void) = (bool (*)(void))execute_func;
        
        if (pipeline_execute) {
            printf("   Attempting execution...\n");
            if (pipeline_execute()) {
                printf("   ✓ Execution completed\n");
            } else {
                printf("   WARNING: Execution failed\n");
            }
        }
    } else {
        printf("   WARNING: Simple code compilation failed\n");
    }
    
    // 6. 测试词法分析器能力
    printf("\n6. Testing tokenizer capabilities...\n");
    const char* token_test = "int x = 42; float y = 3.14; char* str = \"hello\";";
    printf("   Token test: %s\n", token_test);
    
    if (pipeline_compile(token_test, NULL)) {
        printf("   ✓ Tokenizer handled complex tokens\n");
    } else {
        printf("   WARNING: Tokenizer failed on complex tokens\n");
    }
    
    // 7. 清理
    printf("\n7. Cleaning up...\n");
    module_pipeline.cleanup();
    printf("   ✓ Cleanup completed\n");
    
    printf("\n=== Real Compilation Test Summary ===\n");
    printf("This test reveals the actual capabilities of the pipeline:\n");
    printf("- The implementation exists but may be simplified\n");
    printf("- Some features work, others may need improvement\n");
    printf("- The basic infrastructure is in place\n");
    
    return 0;
}
