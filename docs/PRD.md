# Self-Evolve AI 项目规划 (修订版)

## 1. 项目愿景

能够自我进化的AI系统，通过代码自我修改、编译和优化实现持续进化，最终目标是实现完全自主的通用智能。

## 来自人类的重要提示

- 跨架构自举 + AI协同进化
- 进化范式：单一Loader + 架构特定Runtime + 通用Program，多代自举和AI驱动进化，逐步构建出完整的系统
- 核心是 【ASTC字节码数据结构】，整合 WASM/IR/AST/JIT 等概念
- 围绕ASTC完成兼容c99编译器和VM运行时
- c2astc.c 把c语言编译成astc的库
- loader.exe （后面参考Cosmopolitan编译的跨架构单一加载器），Runtime(负责识别当前硬件环境并加载对应架构的运行时) 和 Program(架构无关程序字节码)
- runtime_{arch}_{bits}.rt 架构依赖二进制，根据硬件架构区分，封装硬件架构和ABI等，实现ASTC虚拟机
- 最早的运行时先以兼容libc为基准，以后会逐步进化出更多更先进的运行时，包括多架构合一运行时等
- program.astc 平台无关程序（ASTC格式的二进制模块），未来还会支持program.ir、program.js等的编译

注意：Runtime和Program两种编译的二进制是不一样的。Program编译的是ASTC，Runtime编译的是平台适配的二进制（由ASTC再编译成机器码，且不需要PE/ELF/MACHO头）

其中 loader.exe + runtime{arch}{bits}.rt 或 loader.exe + runtime_{arch}_{bits}.rt 构成了最小化的跨平台执行环境，类似于一个微型的虚拟机，可以执行ASTC格式的程序。

最初的关键在于尽快实现c99兼容的程序(loader+runtime+program_c99）摆脱其它cc依赖

## 2. 三层架构设计

### Layer 1: loader.exe
- 后面要参考Cosmopolitan编译跨架构单一加载器
- 负责识别当前硬件环境并加载对应的运行时
- 提供统一的入口点，简化部署和使用
- 处理命令行参数和初始环境设置

### Layer 2: {runtimeName}_runtime_{arch}_{bits}.rt
- **ASTC JIT编译器生成的架构特定机器码Runtime**
- 命名规范：`{runtimeName}_runtime_{arch}_{bits}.rt`
  - 示例：`evolver0_runtime_x64_64.rt`、`c99_runtime_x64_64.rt`
- 通过astc2rt JIT编译器从ASTC字节码生成x64/ARM等机器码
- 包含完整的ASTC虚拟机和libc转发功能
- 编译流程：C源码 → (c2astc) → ASTC字节码 → (astc2rt JIT) → 机器码Runtime
- 封装硬件架构和ABI，提供系统调用和运行时支持
- 专注于平台libc的转发封装，结构简单但功能完整
- 不需要复杂的符号表机制，只需要最小化的系统接口
- Loader能够根据Program文件名自动选择对应的Runtime文件

### Layer 3: program.astc
- 平台无关程序（ASTC格式的二进制模块）
- 包含可在任何支持的平台上执行的代码
- 未来还会支持program.ir、program.js等其它层的编译
- 基于libc调用简化实现
- 在ASTC/IR层面实现符号表和模块系统
- 包含符号定义和引用、模块导入/导出信息、函数和变量的元数据

## 3. 当前实现状态
see plan.md as running/working plan

## 4. Roadmap - 实现路线图

## 4. Pros - 架构优势分析

## 5. Cons - 技术挑战与解决方案

# 来自人类的重要提示（请智能助理尽量参考）：

- 尽量让会话延续，如果会话在某个会话要停下来之前试一下重读PRD.md后争取自动延续会话ex
- 记得：要从设计和整体来分析问题，不要老是想着简化方案和搞太多测试来回避问题
- 记得：除了代码中的注释或字符串常量使用英文，其它情况下尽量精简且精准的中文；.bat要用英文；
- 记得：临时或测试类的文件放到./tests/
- 记得：你要停下来之前先执行 checkin.bat 或 checkin.sh 接收人类留言
- 记得：运行命令要采取timeout机制，以免有些命令或程序会卡住工作流！
- 经常正思反思然后才行动；注意自主思考和执行；
- 从设计角度来解决问题，不要乱简化来回避问题；

如果任务中等以上复杂程度，智能助理需要使用 docs/plan.md 来进行任务追踪，其中它的内容应该包括：
- ## 任务描述
- ## 非纯性动态规划的任务分解图（使用 mermaid 语法，每个节点有：简单ID、精简标题、评估进度百分比），尽量采用非线性并行工作机制，有利于加速进展
- ## 每个节点的具体任务描述（使用 markdown 语法，要有图中的简单ID、精简标题、评估进度百分比、子任务详细描述）
- ## 跟任务相关的经验和上下文（以确保智能助理不分神）
- ## 注意不要放太多无用的"历史"信息， 内容要尽量保持最新


## 未来增强功能

### 8.1 FFI (Foreign Function Interface) 支持
- **目标**: 实现动态库加载机制，允许运行时加载和调用任意C库函数
- **设计**: 类似Lua/Python的FFI系统，支持动态声明和调用外部函数
- **优势**: 提供更大的灵活性，用户可以调用任意系统库而不需要预先定义
- **实现**: 基于dlopen/dlsym机制，在runtime层提供FFI调用支持


# 来自智能助理自己总结的经验：

## ⚠️ 开发错误避免指南

### 🚫 **严禁的错误模式**：
1. **逃避核心问题** - 不要创建简化版本(如minimal_test.c)来回避复杂问题
2. **硬编码替代真实实现** - 不要用固定值替代真正的编译/转换结果
3. **忽视现有代码** - 必须理解并使用现有组件的真实作用
4. **过早宣布成功** - 程序能编译/运行≠功能正确实现

### ✅ **必须遵循的原则**：
1. **深入理解架构** - 分析每个组件的真实作用和依赖关系
2. **直面技术挑战** - 不逃避复杂的实现问题
3. **验证真实功能** - 确保声称的功能真正工作
4. **诚实评估进度** - 实事求是地评估完成度
