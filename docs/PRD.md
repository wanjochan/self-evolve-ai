# Self-Evolve AI 项目规划 (修订版)

## 1. 项目愿景

创建一个能够真正自我进化的AI系统，通过代码自我修改、编译和优化实现持续进化，最终目标是实现完全自主的智能系统。

## 来自人类的意见参考

跨架构自举 + AI协同进化

本项目自进化范式：采用单一Loader + 架构特定Runtime + 通用Program的结构，通过多代自举和AI驱动的进化，逐步构建出完整的自进化计算机软件系统

核心是一种ASTC的数据结构，整合了WASM/IR/AST的概念，它也是Loader/Runtime/Program的底层逻辑。后面发展高级语言也要由解析器转成它。不过它的压缩率不大，后面可以制作binx二进制码，在执行时才动态把它转ASTC再执行

- c2astc.c 把c语言编译成astc的库
- loader.exe （后面参考Cosmopolitan编译的跨架构单一加载器，）负责识别当前硬件环境并加载对应的运行时和Program.astc
- runtime_{arch}_{bits}.rt 架构依赖二进制，根据硬件架构区分，封装硬件架构和ABI等，实现ASTC虚拟机
- program.astc 平台无关程序（ASTC格式的二进制模块），未来还会支持program.ir、program.js等其它层的编译

注意：Runtime和Program两种编译的二进制是不一样的。Program编译的是ASTC，Runtime编译的是平台适配的二进制（由ASTC再编译成机器码，且不需要PE/ELF/MACHO头）

其中 loader.exe + runtime{arch}{bits}.rt 或 loader.exe + runtime_{arch}_{bits}.rt 构成了最小化的跨平台执行环境，类似于一个微型的虚拟机，可以执行ASTC格式的程序。

## 2. 三层架构设计

### Layer 1: loader.exe
- 后面要参考Cosmopolitan编译跨架构单一加载器
- 负责识别当前硬件环境并加载对应的运行时
- 提供统一的入口点，简化部署和使用
- 处理命令行参数和初始环境设置

### Layer 2: {runtimeName}_runtime_{arch}_{bits}.rt
- **ASTC JIT编译器生成的架构特定机器码Runtime**
- 命名规范：`{runtimeName}_runtime_{arch}_{bits}.rt`
  - 示例：`evolver0_runtime_x64_64.rt`、`c99_runtime_x64_64.rt`
- 通过astc2rt JIT编译器从ASTC字节码生成x64/ARM等机器码
- 包含完整的ASTC虚拟机和libc转发功能
- 编译流程：C源码 → (c2astc) → ASTC字节码 → (astc2rt JIT) → 机器码Runtime
- 封装硬件架构和ABI，提供系统调用和运行时支持
- 专注于平台libc的转发封装，结构简单但功能完整
- 不需要复杂的符号表机制，只需要最小化的系统接口
- Loader能够根据Program文件名自动选择对应的Runtime文件

### Layer 3: program.astc
- 平台无关程序（ASTC格式的二进制模块）
- 包含可在任何支持的平台上执行的代码
- 未来还会支持program.ir、program.js等其它层的编译
- 基于libc调用简化实现
- 在ASTC/IR层面实现符号表和模块系统
- 包含符号定义和引用、模块导入/导出信息、函数和变量的元数据

## 3. 当前实现状态

### 3.1 已完成的系统

#### evolver0系统 (基础自举系统)
- **Loader**: `bin/evolver0_loader.exe` - 跨平台加载器
- **Runtime**: `bin/evolver0_runtime_x64_64.rt` - 基础ASTC虚拟机
- **Program**: `bin/evolver0_program.astc` - 自举编译器程序
- **状态**: 基础架构完成，支持自动Runtime检测

#### C99编译器系统 (生产级编译器)
- **Loader**: `bin/c99_loader.exe` - 跨平台加载器
- **Runtime**: `bin/c99_runtime_x64_64.rt` - 完整C99运行时
- **Program**: `bin/c99_program.astc` - C99编译器程序
- **编译器**: `bin/c99.bat` - TinyCC兼容的C99编译器接口
- **状态**: 架构完成，正在完善编译器功能

### 3.2 核心技术组件
- **c2astc编译器**: C源码到ASTC字节码的转换
- **astc2rt JIT编译器**: ASTC字节码到机器码Runtime的生成
- **智能Runtime检测**: 根据Program文件名自动选择对应Runtime
- **统一文件命名规范**: `{runtimeName}_runtime_{arch}_{bits}.rt`

### 3.3 开发重点调整
当前专注于**C99编译器系统**的完善，待其成熟后再推进evolver0和evolver1的自举功能。

## 4. 实现路线图

### 4.1 当前阶段：C99编译器完善 (优先级最高)
- **目标**: 构建生产级的C99编译器系统
- **任务**:
  - 完善C99语法支持 (词法分析、语法分析、语义分析)
  - 实现完整的C99标准库支持
  - 优化代码生成和ASTC字节码质量
  - 添加编译器优化功能 (-O1, -O2, -O3)
  - 实现调试信息生成 (-g)
  - 完善错误处理和诊断信息
- **验收标准**: 能够编译复杂的C99程序并正确执行

### 4.2 第二阶段：evolver0自举完善
- **前提**: C99编译器系统成熟稳定
- **目标**: 实现真正的自举编译能力
- **任务**:
  - 使用C99编译器重新构建evolver0系统
  - 实现evolver0→evolver1的自举编译
  - 验证自举编译的正确性和稳定性
  - 脱离TinyCC依赖，实现完全自主编译

### 4.3 第三阶段：多平台适配
- 扩展运行时支持更多硬件架构 (ARM64, RISC-V等)
- 完善加载器的平台检测和运行时选择逻辑
- 实现Cosmopolitan风格的跨平台单一可执行文件
- 测试和优化跨平台兼容性

### 4.4 第四阶段：自进化系统
- 开发AI驱动的代码生成和优化组件
- 构建自我进化的反馈循环
- 实现系统自我优化和改进的能力
- 探索代码自动重构和性能优化

## 4. 架构优势分析

### 4.1 部署简化
- 单一加载器简化了分发和安装过程
- 用户只需下载一个可执行文件，系统会自动选择合适的运行时
- 减少了针对不同平台维护多个版本的复杂性

### 4.2 跨平台兼容性
- Cosmopolitan库使得加载器可以在多种平台上运行
- 架构特定的运行时确保了在各平台上的最佳性能
- 通用的ASTC程序格式实现了真正的"一次编写，到处运行"

### 4.3 自进化能力
- 分层设计使系统能够逐步替换和优化自身组件
- AI驱动的进化可以针对不同层次进行优化
- 模块化结构便于实验和改进

### 4.4 Runtime层轻量化设计
- 专注于平台libc的转发封装，避免重复实现已有功能
- 体积极小，减少整体分发包大小
- program.astc可以直接基于libc调用，简化实现
- 未来可能将不同架构的runtime合并到同一个rt文件中
- 接近"单文件分发"的理想状态
- .rt文件结构简单，主要包含ASTC解释器功能
- 复杂的符号表和模块机制在ASTC/IR层面实现，而非在.rt文件中

## 5. 技术挑战与解决方案

### 5.1 跨架构兼容性
- 挑战：确保在不同CPU架构上的一致行为
- 解决方案：严格定义ASTC虚拟机规范，提供架构特定但行为一致的运行时实现

### 5.2 性能优化
- 挑战：解释执行ASTC可能导致性能损失
- 解决方案：实现JIT编译或预编译优化，针对热点代码路径进行特殊优化

### 5.3 自举过程
- 挑战：确保系统能够自我编译和进化
- 解决方案：设计清晰的自举路径，逐步实现自我替换的能力

## 6. 评估指标

- 跨平台兼容性：支持的平台数量和稳定性
- 部署简便性：安装和使用的步骤数量
- 性能：与原生编译相比的执行速度
- 自进化能力：系统自我优化的程度和速度
- 代码质量：可维护性、模块化程度和测试覆盖率

# 来自人类的重要提示（请智能助理尽量参考）：

- 记得：要从设计和整体来分析问题，不要老是想着简化方案和搞太多测试来回避问题
- 记得：除了代码中的注释或字符串常量使用英文，其它情况下尽量精简且精准的中文；.bat要用英文；
- 记得：临时或测试类的文件放到./tests/
- 记得：你要停下来之前先执行 checkin.bat 或 checkin.sh 接收人类留言
- 记得：运行命令要采取timeout机制，以免有些命令或程序会卡住工作流！
- 经常正思反思然后才行动；注意自主思考和执行；
- 从设计角度来解决问题，不要乱简化来回避问题；

如果任务中等以上复杂程度，智能助理需要使用PRD.md（放在当前代码仓根目录）来进行任务追踪，其中它的内容应该包括：
- ## 任务描述
- ## 动态规划的任务分解图（使用 mermaid 语法，每个节点有：简单ID、精简标题、评估进度百分比），尽量采用非线性并行工作机制，有利于加速进展
- ## 每个节点的具体任务描述（使用 markdown 语法，要有图中的简单ID、精简标题、评估进度百分比、子任务详细描述）
- ## 跟任务相关的经验和上下文（以确保智能助理不分神）
- ## 集中用 PRD.md 管理任务，不用开新的 md 文档
- ## 注意不要在 PRD.md 放太多无用的"历史"信息， 内容要尽量保持最新

# 来自智能助理自己总结的经验：

## ⚠️ 开发错误避免指南

### 🚫 **严禁的错误模式**：
1. **逃避核心问题** - 不要创建简化版本(如minimal_test.c)来回避复杂问题
2. **硬编码替代真实实现** - 不要用固定值替代真正的编译/转换结果
3. **忽视现有代码** - 必须理解并使用现有组件的真实作用
4. **过早宣布成功** - 程序能编译/运行≠功能正确实现

### ✅ **必须遵循的原则**：
1. **深入理解架构** - 分析每个组件的真实作用和依赖关系
2. **直面技术挑战** - 不逃避复杂的实现问题
3. **验证真实功能** - 确保声称的功能真正工作
4. **诚实评估进度** - 实事求是地评估完成度

## 7. 架构优势分析

### 7.1 最小化代码改动
- ASTC格式保持不变，现有的编译工具链可以继续使用
- 只需修改加载机制，而不需要改变核心编译流程

### 7.2 简化部署流程
- 单一的loader.exe简化了分发流程
- 用户只需下载一个可执行文件，而不是针对不同平台的多个版本

### 7.3 提高兼容性和性能
- Cosmopolitan库使得loader可以在多种平台上运行
- 架构特定的运行时确保了在各平台上的最佳性能
- 通用的program.astc保证了程序逻辑的一致性

### 7.4 Runtime层轻量化设计
- 专注于平台libc的转发封装，避免重复实现已有功能
- 体积极小，减少整体分发包大小
- program.astc可以直接基于libc调用，简化实现
- 未来可能将不同架构的runtime合并到同一个rt文件中
- 接近"单文件分发"的理想状态

## 8. 未来增强功能

### 8.1 FFI (Foreign Function Interface) 支持
- **目标**: 实现动态库加载机制，允许运行时加载和调用任意C库函数
- **设计**: 类似Lua/Python的FFI系统，支持动态声明和调用外部函数
- **优势**: 提供更大的灵活性，用户可以调用任意系统库而不需要预先定义
- **实现**: 基于dlopen/dlsym机制，在runtime层提供FFI调用支持