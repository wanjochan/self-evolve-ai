# Self-Evolve AI 项目规划

## 1. 项目愿景

能够自我进化的AI系统，通过代码自我修改、编译和优化实现持续进化，最终目标是实现完全自主的通用智能。

## 来自人类的重要提示

- 跨架构自举 + AI协同进化
- 进化范式：单一Loader + 架构特定Runtime + 通用Program，多代自举和AI驱动进化，逐步构建出完整的系统
- 核心是 【ASTC字节码数据结构】，整合 WASM/IR/AST/JIT 等概念
- 围绕ASTC完成兼容c99编译器和VM运行时
- c2astc.c 把c语言编译成astc的库
- loader.exe （后面参考Cosmopolitan编译的跨架构单一加载器），Runtime(负责识别当前硬件环境并加载对应架构的运行时) 和 Program(架构无关程序字节码)
- runtime_{arch}_{bits}.rt 架构依赖二进制，根据硬件架构区分，封装硬件架构和ABI等，实现ASTC虚拟机
- 最早的运行时先以兼容libc为基准，以后会逐步进化出更多更先进的运行时，包括多架构合一运行时等
- program.astc 平台无关程序（ASTC格式的二进制模块），未来还会支持program.ir、program.js等的编译
- **模块化进化**: libc将从转发模式进化为ASTC字节码标准模块，实现真正的自包含系统

注意：Runtime和Program两种编译的二进制是不一样的。Program编译的是ASTC，Runtime编译的是平台适配的二进制（由ASTC再编译成机器码，且不需要PE/ELF/MACHO头）

其中 loader.exe + runtime{arch}{bits}.rt 或 loader.exe + runtime_{arch}_{bits}.rt 构成了最小化的跨平台执行环境，类似于一个微型的虚拟机，可以执行ASTC格式的程序。

最初的关键在于尽快实现c99兼容的程序(loader+runtime+program_c99）摆脱其它cc依赖

## 2. 三层架构设计

### Layer 1: loader.exe
- 后面要参考Cosmopolitan编译跨架构单一加载器
- 负责识别当前硬件环境并加载对应的运行时
- 提供统一的入口点，简化部署和使用
- 处理命令行参数和初始环境设置
- **模块管理**: 负责加载和管理ASTC模块，包括runtime.rt和libc.rt等系统模块

### Layer 2: 运行时模块层
#### 2a. {runtimeName}_runtime_{arch}_{bits}.rt (核心虚拟机)
- **纯ASTC虚拟机**: 专注ASTC字节码执行和JIT编译
- 命名规范：`{runtimeName}_runtime_{arch}_{bits}.rt`
  - 示例：`evolver0_runtime_x64_64.rt`、`c99_runtime_x64_64.rt`
- 通过astc2rt JIT编译器从ASTC字节码生成x64/ARM等机器码
- 核心职责：字节码解释、JIT编译、内存管理、系统调用接口
- 编译流程：C源码 → (c2astc) → ASTC字节码 → (astc2rt JIT) → 机器码Runtime
- **模块加载**: 提供.rt模块的动态加载和符号解析能力

#### 2b. libc.rt (标准库模块)  
- **系统libc转发模块**: 从runtime中分离出来的libc转发封装
- **核心功能**: 将C标准库调用转发到系统libc，提供模块化接口
- **架构优势**: 
  - 职责清晰：runtime.rt专注虚拟机，libc.rt专注标准库转发
  - 统一接口：通过ASTC模块导入导出机制提供标准C99函数
  - 易于替换：可以选择不同版本的libc实现
- **实现基础**: 基于现有`core_libc.c`的转发机制，进行模块化封装
- **版本化支持**: 
  - `libc.rt` - 标准系统libc转发版（主要版本）
  - `libc_os.rt` - 完全自实现版（操作系统开发场景）
  - `libc_minimal.rt` - 精简功能版（嵌入式等特殊场景）
- **模块接口**: 通过标准的ASTC模块导入导出机制提供函数

### Layer 3: program.astc
- 平台无关程序（ASTC格式的二进制模块）
- 包含可在任何支持的平台上执行的代码
- 未来还会支持program.ir、program.js等其它层的编译
- **模块化设计**: 程序可以导入标准库模块和第三方模块
- 在ASTC/IR层面实现符号表和模块系统
- 包含符号定义和引用、模块导入/导出信息、函数和变量的元数据
- **标准库集成**: 通过模块系统使用libc.rt等标准模块

## 3. 模块化系统设计 (新增)

### 3.1 ASTC模块架构
- **模块定义**: 每个模块是独立的ASTC字节码单元(.rt文件)
- **导入/导出**: 基于WASM标准的符号导入导出机制
- **版本管理**: 模块版本兼容性和依赖解析
- **系统模块**: runtime.rt、libc.rt等核心系统模块
- **标准模块**: libc、math、string等核心库模块化

### 3.2 libc.rt模块化架构
```mermaid
graph TD
    A[runtime.rt] --> B[纯ASTC虚拟机]
    A --> C[模块加载器]
    A --> D[JIT编译器]
    
    E[libc.rt] --> F[系统libc转发]
    E --> G[标准C99接口]
    E --> H[ASTC模块导出]
    
    I[program.astc] --> J[用户程序]
    
    C --> E
    J --> G
    
    K[可选扩展]
    K --> L[libc_os.rt<br/>操作系统开发]
    K --> M[libc_minimal.rt<br/>嵌入式场景]
```

### 3.3 模块运行时架构
```mermaid
graph TD
    A[loader.exe] --> B[runtime_x64_64.rt]
    A --> C[libc.rt]
    A --> D[program.astc]
    B --> E[ASTC虚拟机]
    B --> F[JIT编译器]
    B --> G[模块加载器]
    C --> H[stdio函数]
    C --> I[stdlib函数]
    C --> J[string函数]
    G --> C
    G --> K[其他.rt模块]
    D --> L[用户程序代码]
    L --> H
    L --> I
    L --> J
```

### 3.4 模块接口设计
- **runtime.rt接口**: 提供ASTC执行环境和模块管理
- **libc.rt接口**: 提供标准C99函数，通过ASTC模块导出
- **模块发现**: loader自动发现和加载依赖的.rt模块
- **符号解析**: 运行时动态解析模块间的函数调用
- **性能优化**: 模块间调用的零拷贝优化和JIT内联

## 4. 当前实现状态

### 4.1 技术基础 (85%完成)
- **ASTC架构**: core_astc.h 536行，完美兼容WASM并扩展C99
- **C99编译器**: compiler_c2astc.c 6056行，支持完整C99特性
- **JIT编译器**: compiler_astc2rt.c 803行，支持x64/ARM64架构
- **虚拟机**: vm_astc.c 1694行，完整的ASTC执行环境
- **加载器**: core_loader.c 643行，三层架构加载管理

### 4.2 模块化准备 (15%完成)
- **ASTC节点**: 已有MODULE/IMPORT/EXPORT基础节点
- **符号系统**: 基础符号表机制已实现
- **libc转发**: 当前采用转发模式，为模块化奠定基础
- **待开发**: 模块解析、链接、版本管理等功能

## 5. Roadmap - 实现路线图

### 5.1 Phase 1: 自举完成 (当前优先级)
- 消除TinyCC依赖，建立完全独立的编译循环
- 验证三层架构的端到端功能
- 确保系统能使用自己的工具编译自身

### 5.2 Phase 2: 架构模块化 (下一阶段)
- 实现libc.rt模块：将现有libc转发功能独立封装
- 完善runtime.rt：专注纯ASTC虚拟机功能
- 建立.rt模块的标准接口和加载机制
- 验证runtime.rt + libc.rt + program.astc的三层调用

### 5.3 Phase 3: 功能完善 (中期目标)
- 优化模块间调用性能和内存管理
- 完善多架构支持（ARM64等）
- 建立完整的工具链测试和验证框架
- 实现.rt模块的版本管理机制

### 5.4 Phase 4: 扩展生态 (长期目标)
- 开发libc_os.rt用于操作系统开发场景
- AI驱动的代码分析和优化
- 支持第三方.rt模块开发
- 建立模块仓库和分发机制

## 6. Pros - 架构优势分析

### 6.1 模块化优势
- **真正自包含**: 不再依赖宿主系统libc，完全自主控制
- **跨平台一致性**: 同一套标准库在所有平台行为完全一致
- **性能可控**: 在ASTC层面进行全局优化，性能可能更好
- **易于进化**: 模块化设计便于AI驱动的增量改进

### 6.2 架构一致性
- **设计统一**: 从程序到标准库都是ASTC模块，架构高度一致
- **工具链复用**: 同一套编译工具链处理所有模块
- **调试友好**: 统一的调试和分析工具
- **版本管理**: 精细化的模块版本控制和依赖管理

## 7. Cons - 技术挑战与解决方案

### 7.1 模块化挑战
- **性能开销**: 模块调用可能引入额外开销
  - *解决方案*: 设计高效的模块间调用机制，JIT优化
- **内存管理**: 模块间内存共享的复杂性
  - *解决方案*: 设计清晰的内存边界和共享协议
- **启动时间**: 多模块加载影响启动性能
  - *解决方案*: 智能预加载和延迟加载策略

### 7.2 兼容性挑战
- **现有代码迁移**: 从转发模式到模块模式的平滑过渡
  - *解决方案*: 设计混合模式，支持渐进式迁移
- **标准兼容**: 确保模块化后仍然兼容C99标准
  - *解决方案*: 严格按照C99规范设计模块接口

# 来自人类的重要提示（请智能助理尽量参考）：

- 尽量让会话延续，如果会话在某个会话要停下来之前试一下重读PRD.md后争取自动延续会话ex
- 记得：要从设计和整体来分析问题，不要老是想着简化方案和搞太多测试来回避问题
- 记得：除了代码中的注释或字符串常量使用英文，其它情况下尽量精简且精准的中文；.bat要用英文；
- 记得：临时或测试类的文件放到./tests/
- 记得：你要停下来之前先执行 checkin.bat 或 checkin.sh 接收人类留言
- 记得：运行命令要采取timeout机制，以免有些命令或程序会卡住工作流！
- 经常正思反思然后才行动；注意自主思考和执行；
- 从设计角度来解决问题，不要乱简化来回避问题；
- **模块化设计**: 优先考虑系统的模块化和可扩展性，为AI进化奠定基础

## 未来增强功能

### 8.1 FFI (Foreign Function Interface) 支持
- **目标**: 实现动态库加载机制，允许运行时加载和调用任意C库函数
- **设计**: 类似Lua/Python的FFI系统，支持动态声明和调用外部函数
- **优势**: 提供更大的灵活性，用户可以调用任意系统库而不需要预先定义
- **实现**: 基于dlopen/dlsym机制，在runtime层提供FFI调用支持
- **模块化集成**: FFI功能也将模块化，支持安全的外部库集成

### 8.2 ASTC模块生态
- **标准库套件**: stdio、stdlib、string、math等核心模块
- **第三方模块**: 支持社区开发的ASTC模块
- **模块仓库**: 类似npm的ASTC模块管理系统
- **安全验证**: 模块签名和安全扫描机制

# 来自智能助理自己总结的经验：

## ⚠️ 开发错误避免指南

### 🚫 **严禁的错误模式**：
1. **逃避核心问题** - 不要创建简化版本(如minimal_test.c)来回避复杂问题
2. **硬编码替代真实实现** - 不要用固定值替代真正的编译/转换结果
3. **忽视现有代码** - 必须理解并使用现有组件的真实作用
4. **过早宣布成功** - 程序能编译/运行≠功能正确实现
5. **忽视模块化设计** - 新功能开发要考虑模块化架构

### ✅ **必须遵循的原则**：
1. **深入理解架构** - 分析每个组件的真实作用和依赖关系
2. **直面技术挑战** - 不逃避复杂的实现问题
3. **验证真实功能** - 确保声称的功能真正工作
4. **诚实评估进度** - 实事求是地评估完成度
5. **模块化思维** - 设计时考虑模块间的接口和依赖关系
