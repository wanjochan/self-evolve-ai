# Self-Evolve AI 项目规划 (修订版)

## 1. 项目愿景

创建一个能够真正自我进化的AI系统，通过代码自我修改、编译和优化实现持续进化，最终目标是实现完全自主的智能系统。

## 来自人类的意见参考

跨架构自举 + AI协同进化

本项目自进化范式：采用单一Loader + 架构特定Runtime + 通用Program的结构，通过多代自举和AI驱动的进化，逐步构建出完整的自进化计算机软件系统

核心是一种ASTC的数据结构，整合了WASM/IR/AST的概念，它也是Loader/Runtime/Program的底层逻辑。后面发展高级语言也要由解析器转成它。不过它的压缩率不大，后面可以制作binx二进制码，在执行时才动态把它转ASTC再执行

- c2astc.c 把c语言编译成astc的库
- loader.exe 使用Cosmopolitan编译的跨架构单一加载器，负责识别当前硬件环境并加载对应的运行时和Program.astc
- runtime{arch}{bits}.rt 架构依赖二进制，根据硬件架构区分，封装硬件架构和ABI等，实现ASTC虚拟机
- program.astc 平台无关程序（ASTC格式的二进制模块），未来还会支持program.ir、program.js等其它层的编译

注意：Runtime和Program两种编译的二进制是不一样的。Program编译的是ASTC，Runtime编译的是平台适配的二进制（由ASTC再编译成机器码，且不需要PE/ELF/MACHO头）

其中 loader.exe + runtime{arch}{bits}.rt 或 loader.exe + runtime{arch}{bits}.bin 构成了最小化的跨平台执行环境，类似于一个微型的虚拟机，可以执行ASTC格式的程序。

## 2. 三层架构设计

### Layer 1: loader.exe
- 使用Cosmopolitan编译的跨架构单一加载器
- 负责识别当前硬件环境并加载对应的运行时
- 提供统一的入口点，简化部署和使用
- 处理命令行参数和初始环境设置

### Layer 2: runtime{arch}{bits}.rt
- 架构依赖二进制，根据硬件架构区分
- 封装硬件架构和ABI等，实现ASTC虚拟机
- 提供基本的系统调用和运行时支持
- 专注于平台libc的转发封装，体积更小，可能合并多架构支持
- 结构简单，基本只有main()入口点和ASTC解释器功能
- 不需要复杂的符号表机制，只需要最小化的系统接口

### Layer 3: program.astc
- 平台无关程序（ASTC格式的二进制模块）
- 包含可在任何支持的平台上执行的代码
- 未来还会支持program.ir、program.js等其它层的编译
- 基于libc调用简化实现
- 在ASTC/IR层面实现符号表和模块系统
- 包含符号定义和引用、模块导入/导出信息、函数和变量的元数据

## 3. 实现路线图

### 3.1 第一阶段：基础架构转换
- 将现有的三层架构转换为新的Loader + Runtime + Program模式
- 实现使用Cosmopolitan编译的单一加载器
- 创建初始的架构特定运行时文件
- 确保现有ASTC程序能在新架构下正常运行

### 3.2 第二阶段：多平台适配
- 扩展运行时支持更多硬件架构
- 完善加载器的平台检测和运行时选择逻辑
- 测试和优化跨平台兼容性

### 3.3 第三阶段：自举进化
- 实现系统自我编译和优化的能力
- 开发AI驱动的代码生成和优化组件
- 构建自我进化的反馈循环

### 3.4 第四阶段：Runtime层优化
- 重构Runtime层为轻量级libc转发封装
- 减小Runtime体积，提高执行效率
- 探索将多架构Runtime合并到单一rt文件的可能性
- 优化ASTC解释器性能
- 增强ASTC格式，在ASTC层面实现符号表和模块系统

## 4. 架构优势分析

### 4.1 部署简化
- 单一加载器简化了分发和安装过程
- 用户只需下载一个可执行文件，系统会自动选择合适的运行时
- 减少了针对不同平台维护多个版本的复杂性

### 4.2 跨平台兼容性
- Cosmopolitan库使得加载器可以在多种平台上运行
- 架构特定的运行时确保了在各平台上的最佳性能
- 通用的ASTC程序格式实现了真正的"一次编写，到处运行"

### 4.3 自进化能力
- 分层设计使系统能够逐步替换和优化自身组件
- AI驱动的进化可以针对不同层次进行优化
- 模块化结构便于实验和改进

### 4.4 Runtime层轻量化设计
- 专注于平台libc的转发封装，避免重复实现已有功能
- 体积极小，减少整体分发包大小
- program.astc可以直接基于libc调用，简化实现
- 未来可能将不同架构的runtime合并到同一个rt文件中
- 接近"单文件分发"的理想状态
- .rt文件结构简单，主要包含ASTC解释器功能
- 复杂的符号表和模块机制在ASTC/IR层面实现，而非在.rt文件中

## 5. 技术挑战与解决方案

### 5.1 跨架构兼容性
- 挑战：确保在不同CPU架构上的一致行为
- 解决方案：严格定义ASTC虚拟机规范，提供架构特定但行为一致的运行时实现

### 5.2 性能优化
- 挑战：解释执行ASTC可能导致性能损失
- 解决方案：实现JIT编译或预编译优化，针对热点代码路径进行特殊优化

### 5.3 自举过程
- 挑战：确保系统能够自我编译和进化
- 解决方案：设计清晰的自举路径，逐步实现自我替换的能力

## 6. 评估指标

- 跨平台兼容性：支持的平台数量和稳定性
- 部署简便性：安装和使用的步骤数量
- 性能：与原生编译相比的执行速度
- 自进化能力：系统自我优化的程度和速度
- 代码质量：可维护性、模块化程度和测试覆盖率

# 来自人类的重要提示（请智能助理尽量参考）：

- 记得：要从设计和整体来分析问题，不要老是想着简化方案和搞太多测试来回避问题
- 记得：除了代码中的注释或字符串常量使用英文，其它情况下尽量精简且精准的中文；.bat要用英文；
- 记得：临时或测试类的文件放到./tests/
- 记得：你要停下来之前先执行 checkin.bat 或 checkin.sh 接收人类留言
- 记得：运行命令要采取timeout机制，以免有些命令或程序会卡住工作流！
- 经常正思反思然后才行动；注意自主思考和执行；
- 从设计角度来解决问题，不要乱简化来回避问题；

如果任务中等以上复杂程度，智能助理需要使用PRD.md（放在当前代码仓根目录）来进行任务追踪，其中它的内容应该包括：
- ## 任务描述
- ## 动态规划的任务分解图（使用 mermaid 语法，每个节点有：简单ID、精简标题、评估进度百分比），尽量采用非线性并行工作机制，有利于加速进展
- ## 每个节点的具体任务描述（使用 markdown 语法，要有图中的简单ID、精简标题、评估进度百分比、子任务详细描述）
- ## 跟任务相关的经验和上下文（以确保智能助理不分神）
- ## 集中用 PRD.md 管理任务，不用开新的 md 文档
- ## 注意不要在 PRD.md 放太多无用的"历史"信息， 内容要尽量保持最新

# 来自智能助理自己总结的经验：

## ⚠️ 开发错误避免指南

### 🚫 **严禁的错误模式**：
1. **逃避核心问题** - 不要创建简化版本(如minimal_test.c)来回避复杂问题
2. **硬编码替代真实实现** - 不要用固定值替代真正的编译/转换结果
3. **忽视现有代码** - 必须理解并使用现有组件的真实作用
4. **过早宣布成功** - 程序能编译/运行≠功能正确实现

### ✅ **必须遵循的原则**：
1. **深入理解架构** - 分析每个组件的真实作用和依赖关系
2. **直面技术挑战** - 不逃避复杂的实现问题
3. **验证真实功能** - 确保声称的功能真正工作
4. **诚实评估进度** - 实事求是地评估完成度

## 7. 架构优势分析

### 7.1 最小化代码改动
- ASTC格式保持不变，现有的编译工具链可以继续使用
- 只需修改加载机制，而不需要改变核心编译流程

### 7.2 简化部署流程
- 单一的loader.exe简化了分发流程
- 用户只需下载一个可执行文件，而不是针对不同平台的多个版本

### 7.3 提高兼容性和性能
- Cosmopolitan库使得loader可以在多种平台上运行
- 架构特定的运行时确保了在各平台上的最佳性能
- 通用的program.astc保证了程序逻辑的一致性

### 7.4 Runtime层轻量化设计
- 专注于平台libc的转发封装，避免重复实现已有功能
- 体积极小，减少整体分发包大小
- program.astc可以直接基于libc调用，简化实现
- 未来可能将不同架构的runtime合并到同一个rt文件中
- 接近"单文件分发"的理想状态 