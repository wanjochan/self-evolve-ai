# 工作笔记 core_c99

本文档包含工作流 core_c99 的上下文、经验和工作会话笔记，以保持AI会话之间的连续性。

## 工作流信息
- 工作ID: core_c99
- 创建时间: 2023-06-20
- 关联计划: [工作计划文档](workplan_core_c99.md)

## 会话历史

### 会话：2023-06-20

#### 上下文
- 初始分析PRD.md文档，确定核心模块和C99编译器的开发范围
- 检查了src/core/和src/c99/目录的现有代码结构
- 了解了项目的整体架构和技术栈

#### 已执行操作
- 创建了工作计划workplan_core_c99.md
- 分析了src/core/astc.h和src/core/astc.c的代码结构
- 初步评估了各模块的完成度和依赖关系

#### 发现
- src/core/astc.c中存在内存管理问题，可能导致内存泄漏
- src/c99/frontend/c99_lexer.c的词法分析器已基本完成，但缺少对复杂预处理指令的支持
- src/core/convertor/目录下的转换器模块接口设计良好，但实现不完整

#### 挑战
- ASTC到本地代码的转换需要考虑多平台兼容性，特别是在不同操作系统和CPU架构上
- C99语义分析的复杂度超出预期，特别是在处理复杂类型和作用域规则方面
- JIT编译模块的性能优化需要深入了解底层平台特性

#### 决策
- 优先解决astc.c中的内存管理问题，这是阻碍进一步开发的关键障碍
- 采用增量开发策略，先完成核心功能，再添加高级特性
- 为关键模块编写单元测试，确保代码质量和稳定性

## 技术决策记录

### ASTC指令设计
- 采用字节码格式，每条指令包含操作码和操作数
- 操作码使用1字节，便于解码和扩展
- 操作数使用统一的联合体结构，支持多种数据类型
- 特殊处理libc调用，使用专门的操作码和函数ID

### 代码生成策略
- 基于栈的计算模型，简化代码生成
- 使用架构特定的代码生成表，支持跨平台
- 对常用操作进行优化，如printf调用和常量加载
- 保持生成代码的简单性，便于调试和维护

### 错误处理
- 采用详细的错误消息和日志
- 在关键点进行参数验证
- 生成NOP指令作为未知指令的默认处理
- 提供错误码以便上层处理


## 知识库

### 系统架构
- 项目采用分层架构，从底层到高层依次为：
  - Layer1: 加载器(loader)
  - Layer2: 本地代码模块(native modules)
  - Layer3: ASTC代码和C99编译器
- 核心模块(src/core/)提供基础设施，包括ASTC表示、转换器和JIT编译功能
- C99编译器(src/c99/)负责将C99代码转换为ASTC表示

### 关键组件
- ASTC模块: 定义抽象语法树代码的数据结构和操作
- 转换器模块: 包含astc2native和c2astc两个转换器
- JIT编译模块: 提供即时编译功能，优化运行时性能
- C99前端: 包括词法分析、语法分析和语义分析
- C99后端: 负责中间代码生成、优化和目标代码生成

### 重要模式
- 访问者模式: 在ASTC模块中用于遍历和转换抽象语法树
- 工厂模式: 在转换器模块中用于创建不同类型的转换器
- 命令模式: 在编译器工具链中用于实现可撤销的操作

## 参考资料

- [C99标准文档](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)
- [LLVM编译器架构](https://llvm.org/docs/)
- 项目内部文档: docs/elf.md (ELF文件格式说明)

