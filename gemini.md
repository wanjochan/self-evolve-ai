# Gemini 对自进化 AI 项目的分析

本文档基于 `plan.md` 和代码仓结构，分析了项目的愿景、架构及开发流程。

## 1. 项目愿景

项目的最终目标是创建一个真正的**自进化人工智能**。该系统通过迭代式地自我修改、重编译和优化代码，以实现完全自主，最终从一个简单的初始系统逐步增强其智能和能力。

## 2. 核心架构

架构采用三层模型，旨在将平台特定组件与核心进化逻辑分离：

*   **第一层: 加载器 (`Loader-{arch}.exe`)**: 平台相关的引导程序。负责将运行时（Runtime）和程序（Program）加载到内存并启动执行。它处理与操作系统的初始交互（如解析PE/ELF头），初期版本由TCC编译，目标是被自生成的加载器取代。

*   **第二层: 运行时 (`Runtime-{arch}`)**: 平台相关的虚拟机。通过抽象硬件和操作系统细节（如ABI、系统调用），为程序提供标准化的执行环境，专门用于解释和执行自定义的 `ASTC` 格式。

*   **第三层: 程序 (`Program.astc`)**: 平台无关的AI“大脑”。包含自我进化、学习和适应的核心逻辑。程序以 `ASTC` 格式存储，使AI能像处理数据一样操作自身逻辑。`evolver` 系列代表了该组件的不同代际。

## 3. 关键数据结构: ASTC

**ASTC (Abstract Syntax Tree Code)** 是项目的核心数据格式，作为一种自定义的、平台无关的代码中间表示，概念上类似于 LLVM IR 或 WebAssembly。

*   **目的**: 统一系统中的代码逻辑表示。高级语言（如C）通过 `c2astc` 工具编译为 ASTC。
*   **功能**: `Runtime` 负责执行 ASTC。`Program` 本身也以此格式存储，使其能通过操纵此树状结构来分析、修改和生成自身代码。

## 4. 进化策略: 自举 (Bootstrapping)

项目采用自举（或称“自托管”）策略，以摆脱对外部工具的依赖。

*   **`evolver0`**: “创世”编译器，由C语言编写并由TCC编译。其唯一目的是编译下一代 `evolver1`。
*   **`evolver1`**: 第一个自编译的编译器。它比 `evolver0` 更先进，能生成 `ASTC` 输出，是打破对外部TCC依赖、实现核心进化循环的关键一步。
*   **未来代际 (`evolver2`, ...)**: 规划了持续的进化链，每一代都比前代更强，并最终集成AI驱动的代码生成和优化算法。

## 5. 开发与协作模型

项目遵循结构化、规范化的开发流程：

*   **测试**: `/tests` 目录和 `plan.md` 中的详细测试结果表明项目高度重视验证和代码健壮性。
*   **人机协作**: `plan.md` 定义了一个独特的人机协作框架，要求AI助理使用 `aitasker.md` 进行结构化任务管理（包括使用Mermaid图）。这表明了一个高级工作流：人类提供高层指导，AI透明、有组织地执行开发任务。

## 6. 进化状态分析

根据当前对话分析，项目进化状态如下：

*   **核心进化链已独立**: 项目已实现自举。`evolver0` 系统 (`loader` + `runtime` + `program.astc`) 作为一个编译器，可以将新的C语言编译器源码（如 `evolver1_program.c`）编译成新的 `.astc` 程序。此过程**不依赖**外部的TinyCC编译器。

*   **初始构建仍存依赖**: 项目的“第一次启动”仍需外部工具。`loader` 组件 (`evolver0_loader.exe`) 本身需要由一个标准C编译器（如TinyCC）从 `.c` 文件编译而来。

*   **进化路径厘清**:
    *   **程序 (Program) 进化**: 这是当前已实现的进化模式。例如，将一个功能更强的编译器源码 `program_c99.c` 作为输入，提供给当前 `evolver0` 系统，编译输出新的 `program_c99.astc`。其通用路径为：`新版C源码 -> [当前编译器系统] -> 新版Program.astc`。
    *   **运行时 (Runtime) 进化**: 这是更高级的进化目标。它要求编译器具备代码生成后端，路径为：`ASTC -> [编译器系统] -> 原生机器码`。此能力目前尚不具备。

**结论**: 项目的**逻辑核心（Program）已在自我进化**，但**整个系统的完全独立**（包括初始引导程序）是下一步的目标。

---
## 用户偏好

*   **语言风格**: 回答应保持精简 (concise) 和精确 (precise) 的中文。